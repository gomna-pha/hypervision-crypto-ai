#!/usr/bin/env python3
"""
Professional Backtesting Engine for HyperVision Platform
Implements industry-standard backtesting with vectorized operations,
realistic market simulation, and comprehensive performance metrics.
"""

import numpy as np
import pandas as pd
from typing import Dict, List, Optional, Tuple, Any, Union
from dataclasses import dataclass, field
from datetime import datetime, timedelta
import logging
from enum import Enum
import json
import pickle
from collections import defaultdict, deque
import warnings
warnings.filterwarnings('ignore')

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# ==================== Data Models ====================

@dataclass
class BacktestConfig:
    """Configuration for backtesting engine"""
    start_date: datetime
    end_date: datetime
    initial_capital: float = 1000000.0
    leverage: float = 1.0
    commission_rate: float = 0.0002  # 0.02%
    slippage_model: str = "linear"  # linear, square_root, market_impact
    slippage_factor: float = 0.0001
    min_trade_size: float = 0.001
    max_position_size: float = 100000
    risk_free_rate: float = 0.02  # 2% annual
    benchmark: Optional[str] = "BTC/USD"
    data_frequency: str = "1m"  # 1m, 5m, 15m, 1h, 1d
    enable_shorting: bool = True
    margin_call_level: float = 0.25  # 25% of initial capital
    
@dataclass
class TradeSignal:
    """Trading signal generated by strategy"""
    timestamp: datetime
    symbol: str
    action: str  # BUY, SELL, HOLD
    quantity: float
    signal_strength: float  # -1 to 1
    strategy_name: str
    metadata: Dict[str, Any] = field(default_factory=dict)

@dataclass
class BacktestTrade:
    """Executed trade in backtest"""
    trade_id: str
    timestamp: datetime
    symbol: str
    side: str  # BUY, SELL
    quantity: float
    price: float
    commission: float
    slippage: float
    pnl: float = 0.0
    cumulative_pnl: float = 0.0
    position_value: float = 0.0
    
@dataclass
class BacktestResults:
    """Comprehensive backtest results"""
    # Performance metrics
    total_return: float
    annual_return: float
    sharpe_ratio: float
    sortino_ratio: float
    calmar_ratio: float
    max_drawdown: float
    max_drawdown_duration: int
    win_rate: float
    profit_factor: float
    
    # Risk metrics
    var_95: float  # Value at Risk
    cvar_95: float  # Conditional VaR
    beta: float
    alpha: float
    volatility: float
    downside_deviation: float
    
    # Trading statistics
    total_trades: int
    winning_trades: int
    losing_trades: int
    avg_win: float
    avg_loss: float
    best_trade: float
    worst_trade: float
    avg_trade_duration: float
    
    # Time series data
    equity_curve: pd.Series
    returns: pd.Series
    drawdown_series: pd.Series
    trades: List[BacktestTrade]
    
    # Additional metrics
    information_ratio: float
    omega_ratio: float
    recovery_factor: float
    ulcer_index: float
    tail_ratio: float

# ==================== Market Simulator ====================

class MarketSimulator:
    """Simulates realistic market conditions for backtesting"""
    
    def __init__(self, config: BacktestConfig):
        self.config = config
        self.order_book_depth = {}
        self.market_impact_model = self._create_impact_model()
        
    def _create_impact_model(self):
        """Create market impact model based on order size"""
        def impact(size: float, avg_volume: float) -> float:
            # Almgren-Chriss model simplified
            participation_rate = size / avg_volume
            if participation_rate < 0.01:
                return 0.0001
            elif participation_rate < 0.05:
                return 0.0005
            elif participation_rate < 0.1:
                return 0.001
            else:
                return 0.002 * np.sqrt(participation_rate)
        return impact
    
    def calculate_slippage(self, size: float, price: float, 
                          avg_volume: float, volatility: float) -> float:
        """Calculate realistic slippage based on market conditions"""
        if self.config.slippage_model == "linear":
            slippage = self.config.slippage_factor * price
        elif self.config.slippage_model == "square_root":
            slippage = self.config.slippage_factor * price * np.sqrt(size)
        elif self.config.slippage_model == "market_impact":
            impact = self.market_impact_model(size, avg_volume)
            slippage = price * impact * (1 + volatility)
        else:
            slippage = 0
            
        return slippage
    
    def simulate_order_fill(self, signal: TradeSignal, 
                           current_price: float, 
                           volume_profile: Dict) -> Tuple[float, float]:
        """Simulate order execution with realistic fill price"""
        avg_volume = volume_profile.get('avg_volume', 10000)
        volatility = volume_profile.get('volatility', 0.02)
        spread = volume_profile.get('spread', 0.0001)
        
        # Calculate slippage
        slippage = self.calculate_slippage(
            signal.quantity, current_price, avg_volume, volatility
        )
        
        # Adjust price based on order side
        if signal.action == "BUY":
            fill_price = current_price * (1 + spread/2) + slippage
        else:
            fill_price = current_price * (1 - spread/2) - slippage
            
        # Calculate commission
        commission = abs(signal.quantity * fill_price * self.config.commission_rate)
        
        return fill_price, commission

# ==================== Performance Analytics ====================

class PerformanceAnalyzer:
    """Calculates comprehensive performance metrics"""
    
    def __init__(self, config: BacktestConfig):
        self.config = config
        self.risk_free_rate = config.risk_free_rate
        
    def calculate_metrics(self, equity_curve: pd.Series, 
                         trades: List[BacktestTrade],
                         benchmark_returns: Optional[pd.Series] = None) -> BacktestResults:
        """Calculate all performance metrics"""
        
        # Calculate returns
        returns = equity_curve.pct_change().dropna()
        
        # Basic metrics
        total_return = (equity_curve.iloc[-1] / equity_curve.iloc[0]) - 1
        annual_return = self._annualized_return(total_return, len(returns))
        volatility = returns.std() * np.sqrt(252)
        
        # Sharpe ratio
        sharpe_ratio = self._calculate_sharpe(returns, self.risk_free_rate)
        
        # Sortino ratio
        sortino_ratio = self._calculate_sortino(returns, self.risk_free_rate)
        
        # Drawdown analysis
        drawdown_series = self._calculate_drawdown(equity_curve)
        max_drawdown = drawdown_series.min()
        max_dd_duration = self._max_drawdown_duration(drawdown_series)
        
        # Calmar ratio
        calmar_ratio = annual_return / abs(max_drawdown) if max_drawdown != 0 else 0
        
        # Trade statistics
        trade_stats = self._analyze_trades(trades)
        
        # Risk metrics
        var_95 = self._calculate_var(returns, 0.95)
        cvar_95 = self._calculate_cvar(returns, 0.95)
        
        # Market correlation metrics
        if benchmark_returns is not None:
            beta, alpha = self._calculate_beta_alpha(returns, benchmark_returns)
        else:
            beta, alpha = 0, annual_return
            
        # Advanced metrics
        downside_dev = self._downside_deviation(returns)
        info_ratio = self._information_ratio(returns, benchmark_returns)
        omega_ratio = self._omega_ratio(returns, self.risk_free_rate/252)
        recovery_factor = total_return / abs(max_drawdown) if max_drawdown != 0 else 0
        ulcer_index = self._ulcer_index(drawdown_series)
        tail_ratio = self._tail_ratio(returns)
        
        return BacktestResults(
            total_return=total_return,
            annual_return=annual_return,
            sharpe_ratio=sharpe_ratio,
            sortino_ratio=sortino_ratio,
            calmar_ratio=calmar_ratio,
            max_drawdown=max_drawdown,
            max_drawdown_duration=max_dd_duration,
            win_rate=trade_stats['win_rate'],
            profit_factor=trade_stats['profit_factor'],
            var_95=var_95,
            cvar_95=cvar_95,
            beta=beta,
            alpha=alpha,
            volatility=volatility,
            downside_deviation=downside_dev,
            total_trades=trade_stats['total_trades'],
            winning_trades=trade_stats['winning_trades'],
            losing_trades=trade_stats['losing_trades'],
            avg_win=trade_stats['avg_win'],
            avg_loss=trade_stats['avg_loss'],
            best_trade=trade_stats['best_trade'],
            worst_trade=trade_stats['worst_trade'],
            avg_trade_duration=trade_stats['avg_duration'],
            equity_curve=equity_curve,
            returns=returns,
            drawdown_series=drawdown_series,
            trades=trades,
            information_ratio=info_ratio,
            omega_ratio=omega_ratio,
            recovery_factor=recovery_factor,
            ulcer_index=ulcer_index,
            tail_ratio=tail_ratio
        )
    
    def _annualized_return(self, total_return: float, periods: int) -> float:
        """Calculate annualized return"""
        years = periods / 252  # Assuming daily data
        return (1 + total_return) ** (1/years) - 1 if years > 0 else 0
    
    def _calculate_sharpe(self, returns: pd.Series, rf_rate: float) -> float:
        """Calculate Sharpe ratio"""
        excess_returns = returns - rf_rate/252
        if excess_returns.std() == 0:
            return 0
        return np.sqrt(252) * excess_returns.mean() / excess_returns.std()
    
    def _calculate_sortino(self, returns: pd.Series, rf_rate: float) -> float:
        """Calculate Sortino ratio"""
        excess_returns = returns - rf_rate/252
        downside_returns = excess_returns[excess_returns < 0]
        if len(downside_returns) == 0 or downside_returns.std() == 0:
            return 0
        return np.sqrt(252) * excess_returns.mean() / downside_returns.std()
    
    def _calculate_drawdown(self, equity_curve: pd.Series) -> pd.Series:
        """Calculate drawdown series"""
        running_max = equity_curve.expanding().max()
        drawdown = (equity_curve - running_max) / running_max
        return drawdown
    
    def _max_drawdown_duration(self, drawdown: pd.Series) -> int:
        """Calculate maximum drawdown duration in periods"""
        is_drawdown = drawdown < 0
        drawdown_periods = is_drawdown.astype(int).groupby(
            (~is_drawdown).cumsum()
        ).cumsum()
        return drawdown_periods.max() if len(drawdown_periods) > 0 else 0
    
    def _analyze_trades(self, trades: List[BacktestTrade]) -> Dict:
        """Analyze trade statistics"""
        if not trades:
            return {
                'total_trades': 0, 'winning_trades': 0, 'losing_trades': 0,
                'win_rate': 0, 'profit_factor': 0, 'avg_win': 0, 'avg_loss': 0,
                'best_trade': 0, 'worst_trade': 0, 'avg_duration': 0
            }
        
        pnls = [t.pnl for t in trades]
        winning_trades = [p for p in pnls if p > 0]
        losing_trades = [p for p in pnls if p < 0]
        
        win_rate = len(winning_trades) / len(trades) if trades else 0
        
        total_wins = sum(winning_trades) if winning_trades else 0
        total_losses = abs(sum(losing_trades)) if losing_trades else 1
        profit_factor = total_wins / total_losses if total_losses > 0 else 0
        
        return {
            'total_trades': len(trades),
            'winning_trades': len(winning_trades),
            'losing_trades': len(losing_trades),
            'win_rate': win_rate,
            'profit_factor': profit_factor,
            'avg_win': np.mean(winning_trades) if winning_trades else 0,
            'avg_loss': np.mean(losing_trades) if losing_trades else 0,
            'best_trade': max(pnls) if pnls else 0,
            'worst_trade': min(pnls) if pnls else 0,
            'avg_duration': 0  # Would need timestamp data
        }
    
    def _calculate_var(self, returns: pd.Series, confidence: float) -> float:
        """Calculate Value at Risk"""
        return np.percentile(returns, (1 - confidence) * 100)
    
    def _calculate_cvar(self, returns: pd.Series, confidence: float) -> float:
        """Calculate Conditional Value at Risk"""
        var = self._calculate_var(returns, confidence)
        return returns[returns <= var].mean()
    
    def _calculate_beta_alpha(self, returns: pd.Series, 
                             benchmark: pd.Series) -> Tuple[float, float]:
        """Calculate beta and alpha relative to benchmark"""
        if benchmark is None or len(benchmark) == 0:
            return 0, 0
        
        # Align series
        aligned = pd.DataFrame({'returns': returns, 'benchmark': benchmark}).dropna()
        if len(aligned) < 2:
            return 0, 0
            
        cov = aligned.cov()
        var_benchmark = aligned['benchmark'].var()
        
        if var_benchmark == 0:
            return 0, 0
            
        beta = cov.loc['returns', 'benchmark'] / var_benchmark
        alpha = aligned['returns'].mean() - beta * aligned['benchmark'].mean()
        
        return beta, alpha * 252  # Annualized
    
    def _downside_deviation(self, returns: pd.Series) -> float:
        """Calculate downside deviation"""
        negative_returns = returns[returns < 0]
        if len(negative_returns) == 0:
            return 0
        return negative_returns.std() * np.sqrt(252)
    
    def _information_ratio(self, returns: pd.Series, 
                          benchmark: Optional[pd.Series]) -> float:
        """Calculate Information Ratio"""
        if benchmark is None:
            return 0
        
        active_returns = returns - benchmark
        if active_returns.std() == 0:
            return 0
        
        return active_returns.mean() / active_returns.std() * np.sqrt(252)
    
    def _omega_ratio(self, returns: pd.Series, threshold: float) -> float:
        """Calculate Omega Ratio"""
        excess = returns - threshold
        gains = excess[excess > 0].sum()
        losses = abs(excess[excess < 0].sum())
        
        if losses == 0:
            return np.inf if gains > 0 else 0
        
        return gains / losses
    
    def _ulcer_index(self, drawdown: pd.Series) -> float:
        """Calculate Ulcer Index"""
        return np.sqrt(np.mean(drawdown ** 2)) * 100
    
    def _tail_ratio(self, returns: pd.Series) -> float:
        """Calculate Tail Ratio"""
        sorted_returns = returns.sort_values()
        n = len(sorted_returns)
        if n < 20:
            return 0
        
        n_tail = int(n * 0.05)
        right_tail = sorted_returns.iloc[-n_tail:].mean()
        left_tail = sorted_returns.iloc[:n_tail].mean()
        
        if left_tail == 0:
            return 0
        
        return abs(right_tail / left_tail)

# ==================== Backtest Engine ====================

class BacktestEngine:
    """Main backtesting engine with vectorized operations"""
    
    def __init__(self, config: BacktestConfig):
        self.config = config
        self.simulator = MarketSimulator(config)
        self.analyzer = PerformanceAnalyzer(config)
        self.portfolio = Portfolio(config.initial_capital)
        self.trades = []
        self.equity_curve = []
        
    def run_backtest(self, strategy, historical_data: pd.DataFrame) -> BacktestResults:
        """Run complete backtest with strategy"""
        logger.info(f"Starting backtest from {self.config.start_date} to {self.config.end_date}")
        
        # Filter data to backtest period
        mask = (historical_data.index >= self.config.start_date) & \
               (historical_data.index <= self.config.end_date)
        data = historical_data[mask].copy()
        
        if len(data) == 0:
            raise ValueError("No data available for backtest period")
        
        # Initialize equity tracking
        equity_series = pd.Series(index=data.index, dtype=float)
        
        # Run strategy bar by bar
        for i, (timestamp, row) in enumerate(data.iterrows()):
            # Generate signals
            signals = strategy.generate_signals(data.iloc[:i+1], self.portfolio)
            
            # Execute trades
            for signal in signals:
                self._execute_trade(signal, row, timestamp)
            
            # Update portfolio value
            portfolio_value = self.portfolio.get_total_value(row)
            equity_series.iloc[i] = portfolio_value
            self.equity_curve.append(portfolio_value)
            
            # Risk management
            if portfolio_value < self.config.initial_capital * self.config.margin_call_level:
                logger.warning(f"Margin call at {timestamp}, closing all positions")
                self._close_all_positions(row, timestamp)
        
        # Calculate final metrics
        results = self.analyzer.calculate_metrics(
            equity_series.dropna(),
            self.trades,
            data.get('benchmark_returns')
        )
        
        logger.info(f"Backtest complete. Total return: {results.total_return:.2%}")
        return results
    
    def _execute_trade(self, signal: TradeSignal, 
                      market_data: pd.Series, 
                      timestamp: datetime):
        """Execute trade with realistic simulation"""
        current_price = market_data['close']
        
        # Simulate order execution
        volume_profile = {
            'avg_volume': market_data.get('volume', 10000),
            'volatility': market_data.get('volatility', 0.02),
            'spread': market_data.get('spread', 0.0001)
        }
        
        fill_price, commission = self.simulator.simulate_order_fill(
            signal, current_price, volume_profile
        )
        
        # Create trade record
        trade = BacktestTrade(
            trade_id=f"{timestamp}_{signal.symbol}",
            timestamp=timestamp,
            symbol=signal.symbol,
            side=signal.action,
            quantity=signal.quantity,
            price=fill_price,
            commission=commission,
            slippage=abs(fill_price - current_price)
        )
        
        # Update portfolio
        if signal.action == "BUY":
            cost = fill_price * signal.quantity + commission
            if self.portfolio.cash >= cost:
                self.portfolio.cash -= cost
                self.portfolio.positions[signal.symbol] = \
                    self.portfolio.positions.get(signal.symbol, 0) + signal.quantity
                self.trades.append(trade)
        
        elif signal.action == "SELL":
            if self.portfolio.positions.get(signal.symbol, 0) >= signal.quantity:
                self.portfolio.positions[signal.symbol] -= signal.quantity
                self.portfolio.cash += fill_price * signal.quantity - commission
                
                # Calculate PnL
                # This is simplified - in production would track entry prices
                trade.pnl = (fill_price - current_price) * signal.quantity - commission
                self.trades.append(trade)
    
    def _close_all_positions(self, market_data: pd.Series, timestamp: datetime):
        """Close all positions (margin call or end of backtest)"""
        for symbol, quantity in self.portfolio.positions.items():
            if quantity > 0:
                signal = TradeSignal(
                    timestamp=timestamp,
                    symbol=symbol,
                    action="SELL",
                    quantity=quantity,
                    signal_strength=1.0,
                    strategy_name="CLOSE_ALL"
                )
                self._execute_trade(signal, market_data, timestamp)

# ==================== Portfolio Management ====================

class Portfolio:
    """Portfolio tracking for backtesting"""
    
    def __init__(self, initial_capital: float):
        self.initial_capital = initial_capital
        self.cash = initial_capital
        self.positions = {}
        self.trade_history = []
        
    def get_total_value(self, market_prices: pd.Series) -> float:
        """Calculate total portfolio value"""
        positions_value = 0
        for symbol, quantity in self.positions.items():
            if symbol in market_prices:
                positions_value += quantity * market_prices[symbol]
            elif 'close' in market_prices:
                positions_value += quantity * market_prices['close']
        
        return self.cash + positions_value
    
    def get_position_sizes(self) -> Dict[str, float]:
        """Get current position sizes"""
        return self.positions.copy()
    
    def get_exposure(self, market_prices: pd.Series) -> float:
        """Calculate total market exposure"""
        total_value = self.get_total_value(market_prices)
        if total_value == 0:
            return 0
        
        positions_value = total_value - self.cash
        return positions_value / total_value

# ==================== Monte Carlo Simulation ====================

class MonteCarloSimulator:
    """Monte Carlo simulation for strategy robustness testing"""
    
    def __init__(self, config: BacktestConfig):
        self.config = config
        
    def run_simulation(self, strategy, historical_data: pd.DataFrame, 
                      n_simulations: int = 1000) -> Dict[str, Any]:
        """Run Monte Carlo simulation with bootstrapping"""
        logger.info(f"Running {n_simulations} Monte Carlo simulations")
        
        results = []
        returns_data = historical_data['returns'].dropna()
        
        for i in range(n_simulations):
            # Bootstrap returns
            simulated_returns = np.random.choice(
                returns_data, 
                size=len(returns_data), 
                replace=True
            )
            
            # Create simulated price series
            simulated_prices = pd.Series(
                index=historical_data.index[:len(simulated_returns)],
                data=(1 + simulated_returns).cumprod() * historical_data['close'].iloc[0]
            )
            
            # Create simulated dataframe
            sim_data = pd.DataFrame({
                'close': simulated_prices,
                'volume': historical_data['volume'].iloc[:len(simulated_prices)],
                'returns': simulated_returns
            })
            
            # Run backtest on simulated data
            engine = BacktestEngine(self.config)
            try:
                result = engine.run_backtest(strategy, sim_data)
                results.append({
                    'total_return': result.total_return,
                    'sharpe_ratio': result.sharpe_ratio,
                    'max_drawdown': result.max_drawdown,
                    'win_rate': result.win_rate
                })
            except Exception as e:
                logger.warning(f"Simulation {i} failed: {e}")
                continue
        
        # Aggregate results
        df_results = pd.DataFrame(results)
        
        return {
            'mean_return': df_results['total_return'].mean(),
            'std_return': df_results['total_return'].std(),
            'percentile_5': df_results['total_return'].quantile(0.05),
            'percentile_95': df_results['total_return'].quantile(0.95),
            'prob_positive': (df_results['total_return'] > 0).mean(),
            'mean_sharpe': df_results['sharpe_ratio'].mean(),
            'mean_max_dd': df_results['max_drawdown'].mean(),
            'results_df': df_results
        }

# ==================== Walk-Forward Optimization ====================

class WalkForwardOptimizer:
    """Walk-forward optimization for parameter tuning"""
    
    def __init__(self, config: BacktestConfig):
        self.config = config
        
    def optimize(self, strategy_class, historical_data: pd.DataFrame,
                param_ranges: Dict[str, List], 
                train_periods: int = 252, 
                test_periods: int = 63) -> Dict[str, Any]:
        """Perform walk-forward optimization"""
        logger.info("Starting walk-forward optimization")
        
        results = []
        total_periods = len(historical_data)
        
        # Calculate number of windows
        n_windows = (total_periods - train_periods) // test_periods
        
        for window in range(n_windows):
            # Define train and test periods
            train_start = window * test_periods
            train_end = train_start + train_periods
            test_start = train_end
            test_end = test_start + test_periods
            
            if test_end > total_periods:
                break
            
            train_data = historical_data.iloc[train_start:train_end]
            test_data = historical_data.iloc[test_start:test_end]
            
            # Optimize on training data
            best_params = self._optimize_window(
                strategy_class, train_data, param_ranges
            )
            
            # Test on out-of-sample data
            strategy = strategy_class(**best_params)
            test_config = BacktestConfig(
                start_date=test_data.index[0],
                end_date=test_data.index[-1],
                initial_capital=self.config.initial_capital
            )
            
            engine = BacktestEngine(test_config)
            test_result = engine.run_backtest(strategy, test_data)
            
            results.append({
                'window': window,
                'train_start': train_data.index[0],
                'train_end': train_data.index[-1],
                'test_start': test_data.index[0],
                'test_end': test_data.index[-1],
                'best_params': best_params,
                'test_return': test_result.total_return,
                'test_sharpe': test_result.sharpe_ratio,
                'test_max_dd': test_result.max_drawdown
            })
            
            logger.info(f"Window {window}: Test return {test_result.total_return:.2%}")
        
        return {
            'windows': results,
            'avg_return': np.mean([r['test_return'] for r in results]),
            'avg_sharpe': np.mean([r['test_sharpe'] for r in results]),
            'consistency': np.std([r['test_return'] for r in results])
        }
    
    def _optimize_window(self, strategy_class, data: pd.DataFrame, 
                        param_ranges: Dict[str, List]) -> Dict[str, Any]:
        """Optimize parameters for a single window"""
        best_sharpe = -np.inf
        best_params = {}
        
        # Grid search (simplified - in production use more sophisticated methods)
        from itertools import product
        
        param_combinations = list(product(*param_ranges.values()))
        
        for params in param_combinations:
            param_dict = dict(zip(param_ranges.keys(), params))
            
            try:
                strategy = strategy_class(**param_dict)
                config = BacktestConfig(
                    start_date=data.index[0],
                    end_date=data.index[-1],
                    initial_capital=self.config.initial_capital
                )
                
                engine = BacktestEngine(config)
                result = engine.run_backtest(strategy, data)
                
                if result.sharpe_ratio > best_sharpe:
                    best_sharpe = result.sharpe_ratio
                    best_params = param_dict
            except Exception as e:
                logger.debug(f"Failed with params {param_dict}: {e}")
                continue
        
        return best_params

# ==================== Main Entry Point ====================

if __name__ == "__main__":
    # Example usage
    logger.info("Backtesting Engine initialized")
    
    # Create sample config
    config = BacktestConfig(
        start_date=datetime(2023, 1, 1),
        end_date=datetime(2024, 1, 1),
        initial_capital=1000000,
        commission_rate=0.0002,
        slippage_model="market_impact"
    )
    
    # Initialize components
    engine = BacktestEngine(config)
    analyzer = PerformanceAnalyzer(config)
    monte_carlo = MonteCarloSimulator(config)
    optimizer = WalkForwardOptimizer(config)
    
    logger.info("Backtesting system ready for use")